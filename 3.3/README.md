# 作业

## 1.浮点数的表示

文件c1.c  
原理:采用`double` 储存格式为`S | Exponent (11-bit) | Fraction (52-bit)`,用位运算构造如下数值的 double 类型浮点数  
数据构造分析：  
(a) 20250309 和 -20250309  
`20250309 = 0b1001101001101011000101=1.001101001101011000101 × 2²⁴`,
即`0 | 10000010111 | 0011010011010110001010000000000000000000000000000000`,其负数同理。 
(b) -0.0625  
`-0.0625 = -1/16 = -2⁻⁴`,`1.000000000000 × 2⁻⁴`
`1 | 01111110100 | 0000000000000000000000000000000000000000000000000000`
(c) 正无穷和NaN  
`0 | 11111111111 | 0000000000000000000000000000000000000000000000000000`and`0 | 11111111111 | 1000000000000000000000000000000000000000000000000000`

## 整数和浮点数转换

原理和数据分析  

```bash
整数 x: 20250309
负数 -x: -20250309

[int] x: 0|00000010|01101001111111011000101
[int] -x: 1|11111101|10010110000000100111011

[float] (float)x: 20250308.000000
Binary: 0|10010111|00110100111111101100010
[double] (double)x: 20250309.000000
Binary: 0|10000010111|0011010011111110110001010000000000000000000000000000

[公共子串计算] |x| 与 (float)x:
最大公共子串: 100110100111111101100010 (长度: 24)

[公共子串计算] |x| 与 (double)x:
最大公共子串: 1001101001111111011000101 (长度: 25)
```

## GCC 汇编与 objdump 反汇编

分别看c3.s,c3_disassembly.txt,可以得出
GCC 生成的汇编文件  
	•	代码结构更清晰，有符号标识。  
	•	可能有额外的伪指令或优化标记。  
objdump 反汇编目标文件  
	•	只包含最终的机器代码转换结果。  
	•	没有变量名，使用寄存器操作。  
两种方法生成的汇编代码基本一致，但 objdump 反汇编的代码是最终机器指令，省略了 GCC 生成的标记信息。  
不同数据类型运算对应不同的指令，整数与浮点数转换涉及 cvtsi2ss 和 cvtsi2sd，而浮点运算使用 addss / addsd 等指令。  
可以通过优化选项 -O2 或 -O3 让 GCC 生成更高效的代码，减少不必要的转换指令。  

int -> float	`cvtsi2ss xmm, r/m32`  
int -> double	`cvtsi2sd xmm, r/m32`  
float -> double	`cvtss2sd xmm, xmm`  
   
float + float	`addss xmm, xmm`  
double + double	`addsd xmm, xmm`  
float * double	`mulss xmm, xmm`  
double / long	`divsd xmm, xmm`  

  
---
dx